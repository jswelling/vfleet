/****************************************************************************
 * compvren.cc
 * Author Joel Welling
 * Copyright 1993, Pittsburgh Supercomputing Center, Carnegie Mellon University
 *
 * Permission use, copy, and modify this software and its documentation
 * without fee for personal use or use within your organization is hereby
 * granted, provided that the above copyright notice is preserved in all
 * copies and that that copyright and this permission notice appear in
 * supporting documentation.  Permission to redistribute this software to
 * other organizations or individuals is not granted;  that must be
 * negotiated with the PSC.  Neither the PSC nor Carnegie Mellon
 * University make any representations about the suitability of this
 * software for any purpose.  It is provided "as is" without express or
 * implied warranty.
 *****************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <math.h>
#include <sys/types.h>

#if ( CRAY_ARCH_C90 || CRAY_ARCH_T3D || CRAY_ARCH_T3E )
#include <time.h>
#include <unistd.h>
#else /* ifdef CRAY_ARCH_C90 */

#ifdef DECCXX
extern "C" {
#endif

#ifdef SYSV_TIMING
#include <sys/times.h>
#else
#include <sys/time.h>
#endif
#include <sys/resource.h>
#ifdef DECCXX
}
#endif

#endif /* if CRAY_ARCH_C90 or CRAY_ARCH_T3D or CRAY_ARCH_T3E */

#include "basenet.h"
#include "logger.h"
#include "rgbimage.h"
#include "imagehandler.h"
#include "vren.h"
#include "tfun.h"
#include "netvren.h"
#include "compvren.h"
#include "composite.h"

/*
  Notes:
 */

compDataVolume::compDataVolume( int xdim_in, int ydim_in, int zdim_in,
				  const gBoundBox& bbox_in,
				  int nchildren_in, DataVolume **children_in,
				  DataVolume *parent_in )
: DataVolume( 1, 1, zdim_in, bbox_in, parent_in )
{
  real_xdim= xdim_in;
  real_ydim= ydim_in;
  real_zdim= zdim_in;
  grid= GridInfo( 0, 0, 0, bbox_in );

  nchildren= nchildren_in;
  children= new DataVolume*[nchildren];
  for (int i=0; i<nchildren; i++) {
    children[i]= children_in[i];
    children[i]->set_parent( this );
  }

  // These variables are used to handle the case of other objects
  // passing in max gradients while the kids are still calculating theirs
  kids_reporting_max_grad= 0;
  has_outside_max_grad= 0;
  outside_max_grad= 0.0; 
}

compDataVolume::~compDataVolume()
{
  // ***Note that this deletes the DataVolumes passed to the constructor!***
  for (int i=0; i<nchildren; i++) delete children[i];
  delete [] children;
}

void compDataVolume::finish_init()
{
  for (int i=0; i<nchildren; i++) children[i]->finish_init();
}

void compDataVolume::set_max_gradient( const float value,
					DataVolume *caller )
{
  /*
    The algorithm for handling setting of max grads is as follows.
    It is assumed that reports of max grads will come in from all
    the children.  We save up those reports, and broadcast the largest
    value, which is the overall maximum, to all the children when the
    last child has reported.

    However, other objects, like this DataVolume\'s potential ancestors,
    may also be sending in reports.  The most recent such report always
    superceded anything generated by the children.  If the children have
    already reported when such an outside value is passed in, we immediately
    pass it on to the kids.  If not, we buffer it \(keeping the most recent\)
    and apply it when the last child reports.
   */

  if (caller->get_parent() == (DataVolume *)this) {
    // A child is reporting
    kids_reporting_max_grad++;
    if (value > max_grad_mag) max_grad_mag= value;
    if (kids_reporting_max_grad==nchildren) { 
      // Got a flock of results; broadcast best
      if (has_outside_max_grad) {
	max_grad_mag= outside_max_grad;
	has_outside_max_grad= 0;
      }
      for (int i=0; i<nchildren; i++) 
	children[i]->set_max_gradient(max_grad_mag, this);
      if (parent) parent->set_max_gradient(max_grad_mag, this);
    }
  }
  else {
    // outside report, like from a parent, superceding children\'s reports
    if (kids_reporting_max_grad >= nchildren) {
      // dispatch immediately
      max_grad_mag= value;
      for (int i=0; i<nchildren; i++) 
	children[i]->set_max_gradient(max_grad_mag, this);
      if (parent != caller) parent->set_max_gradient(max_grad_mag, this);
    }
    else {
      // save for later
      has_outside_max_grad= 1;
      outside_max_grad= value; // always keep most recent
    }
  }
}

compTransferFunction::compTransferFunction( int ndata_in, int nchildren_in, 
					    baseTransferFunction **kids )
: baseTransferFunction( ndata_in )
{
  nchildren= nchildren_in;
  children= new baseTransferFunction*[nchildren];
  for (int i=0; i<nchildren; i++) children[i]= kids[i];
}

compTransferFunction::~compTransferFunction()
{
  // ****This deletes the tfuns passed in to the constructor!***
  for (int i=0; i<nchildren; i++) delete children[i];
  delete [] children;
}

compSampleVolume::compSampleVolume( const GridInfo& grid_in,
				    baseTransferFunction& tfun_in,
				    int ndatavol, DataVolume** data_table,
				    const int nchildren_in )
: baseSampleVolume( grid_in, tfun_in, ndatavol, data_table )
{
  nchildren= nchildren_in;
  children= new baseSampleVolume*[nchildren];
}

compSampleVolume::~compSampleVolume()
{
  for (int i=0; i<nchildren; i++) delete children[i];
  delete [] children;
}

void compSampleVolume::regenerate( baseTransferFunction& tfun_in,
				    int ndatavol, DataVolume** data_table )
{
  // Take care of bookkeeping
  baseSampleVolume::regenerate( tfun_in, ndatavol, data_table );

  // Cast below works as long as same renderer created tfun_in and this.
  compTransferFunction *c_tfun= (compTransferFunction*)&tfun_in;
  compDataVolume** c_data_table= (compDataVolume **)data_table;

  DataVolume **kid_table= new DataVolume*[ndatavol];
  for (int i=0; i<nchildren; i++) {
    for (int j=0; j<ndatavol; j++) kid_table[j]= c_data_table[j]->child(i);
    children[i]->regenerate( *(c_tfun->child(i)), ndatavol, kid_table );
  }
  delete [] kid_table;
}

void compSampleVolume::set_size_scale( const float new_scale )
{
  baseSampleVolume::set_size_scale( new_scale );
  for (int i=0; i<nchildren; i++)
    children[i]->set_size_scale( new_scale );
}

compVolGob::compVolGob( baseSampleVolume *vol_in, const gTransfm& trans,
			int nchildren_in, baseVRen** child_rens )
: VolGob( vol_in, trans )
{
  // Cast works as long as input SampleVolume was created by same ren as this
  compSampleVolume *c_svol= (compSampleVolume *)vol_in;
  nchildren= nchildren_in;
  children= new VolGob*[nchildren];
  for (int i=0; i<nchildren; i++)
    children[i]= child_rens[i]->create_volgob( c_svol->child(i), trans );
}

compVolGob::~compVolGob()
{
  for (int i=0; i<nchildren; i++) delete children[i];
  delete [] children;
}

void compVolGob::update_trans( const gTransfm& trans_in )
{
  trans= trans_in;
  for (int i=0; i<nchildren; i++) children[i]->update_trans( trans );
}

compVRen::compVRen(const int nchildren_in, 
		   baseLogger *logger, baseImageHandler *imagehandler, 
		   void (*ready_handler)(baseVRen *renderer,
					 void* ready_cb_data_in),
		   void* ready_cb_data_in,
		   void (*error_handler)(int error_id, 
					 baseVRen *renderer), 
		   void (*fatal_handler)(int error_id, 
					 baseVRen *renderer),
		   void (*service_call)()) 
: baseVRen( logger, imagehandler, ready_handler, ready_cb_data_in,
	    error_handler, fatal_handler )
{
  service= service_call;
  current_camera= NULL;
  current_quality= NULL;
  current_light_info= NULL;
  current_geom= NULL;
  image= NULL;
  nchildren= nchildren_in;
  children= new baseVRen*[nchildren];
  num_kids_ready= 0;
}

compVRen::compVRen( const int nchildren_in, 
		    baseLogger *logger, baseImageHandler *imagehandler, 
		    void (*ready_handler)(baseVRen *renderer,
					  void* ready_cb_data_in),
		    void* ready_cb_data_in,
		    baseVRen *owner, void (*service_call)())
: baseVRen( logger, imagehandler, ready_handler, ready_cb_data_in, owner )
{
  service= service_call;
  current_camera= NULL;
  current_quality= NULL;
  current_light_info= NULL;
  current_geom= NULL;
  image= NULL;
  nchildren= nchildren_in;
  children= new baseVRen*[nchildren];
  num_kids_ready= 0;
}

compVRen::~compVRen()
{
  delete current_camera;
  delete current_quality;
  delete current_light_info;
  delete current_geom;
  delete compositor;
  for (int i=0; i<nchildren; i++) delete children[i];
  delete [] children;
}

void compVRen::ready_callback( baseVRen* renderer, void* cb_data )
{
  compVRen* has_ready_child= (compVRen*)cb_data;
  has_ready_child->handle_ready_child( renderer );
}

void compVRen::handle_ready_child( baseVRen* renderer )
{
  num_kids_ready++;
  if (num_kids_ready == nchildren)
    if (ready_proc) (*ready_proc)(this, ready_cb_data);
}

void compVRen::setOptionFlags( const VRenOptions ops )
{
  baseVRen::setOptionFlags( ops );
  for (int i=0; i<nchildren; i++) 
    children[i]->setOptionFlags( ops );
}

void compVRen::setCamera( const gPoint& lookfm, const gPoint& lookat, 
			  const gVector& up, const float fov, 
			  const float hither, const float yon,
			  const int parallel_flag ) 
{
  baseVRen::setCamera( lookfm, lookat, up, fov, hither, yon, parallel_flag );
  for (int i=0; i<nchildren; i++) 
    children[i]->setCamera( lookfm, lookat, up, fov, hither, yon, 
			    parallel_flag );
}

void compVRen::setCamera( const Camera& cam )
{
  baseVRen::setCamera( cam );
  for (int i=0; i<nchildren; i++) children[i]->setCamera( *current_camera );
}

void compVRen::AbortRender()
{
  for (int i=0; i<nchildren; i++) children[i]->AbortRender();
}

void compVRen::StartRender( int image_xdim, int image_ydim )
{
  // Check the status of all needed parts.
  if (!current_camera) {
    error( VRENERROR_CAMERA_NOT_SET );
    return;
  }
  if (!current_quality) {
    error( VRENERROR_QUALITY_NOT_SET );
    return;
  }
  if (!current_light_info) {
    error( VRENERROR_LIGHT_INFO_NOT_SET );
    return;
  }
  if (!current_geom) {
    error( VRENERROR_GEOM_NOT_SET );
    return;
  }

  // Record that we are starting the task
  char msg_buf[80];
  sprintf(msg_buf,"rendering by children at: %4d %4d", image_xdim, image_ydim);
  logger->comment(msg_buf);

  // Tell the compositor to note the time, so it can say how long rendering
  // took.
  compositor->note_start_time();

  // Set up for proper compositing, remembering to transform viewpoint
  gTransfm view_trans= current_geom->volgob()->transform();
  view_trans.transpose_self();
  compositor->set_lookfrom( view_trans*(current_camera->from()) );
  compositor->set_boundbox(current_geom->volgob()->samplevolume()->boundbox());

  // Render the image.
  for (int i=0; i<nchildren; i++) 
    children[i]->StartRender( image_xdim, image_ydim );
}

void compVRen::setQualityMeasure( const QualityMeasure& qual ) 
{
  delete current_quality;
  current_quality= new QualityMeasure(qual);
  for (int i=0; i<nchildren; i++) children[i]->setQualityMeasure( qual );
}

void compVRen::setOpacLimit( float what ) 
{
  if (!current_quality) current_quality= new QualityMeasure;
  current_quality->set_opacity_limit(what);
  for (int i=0; i<nchildren; i++) children[i]->setOpacLimit( what );
}

void compVRen::setColorCompError( float what ) 
{
  if (!current_quality) current_quality= new QualityMeasure;
  current_quality->set_color_comp_error(what);
  for (int i=0; i<nchildren; i++) children[i]->setColorCompError( what );
}

void compVRen::setOpacMinimum( const int what )
{
  if (!current_quality) current_quality= new QualityMeasure;
  current_quality->set_opacity_min(what);
  for (int i=0; i<nchildren; i++) children[i]->setOpacMinimum( what );
}

void compVRen::setLightInfo( const LightInfo& linfo_in ) 
{
  // Set the local copy
  baseVRen::setLightInfo( linfo_in );

  for (int i=0; i<nchildren; i++) children[i]->setLightInfo( linfo_in );
}

void compVRen::setGeometry( VolGob *volgob ) 
{
  // Set the local copy
  baseVRen::setGeometry(volgob);

  // Cast works as long as volgob was created by same renderer as this.
  for (int i=0; i<nchildren; i++)
    children[i]->setGeometry( ((compVolGob*)volgob)->child(i) );
}

void compVRen::update_and_go( const Camera& camera_in, 
			       const LightInfo& lights_in,
			       const int xsize, const int ysize )
{
  // Check the status of all needed parts.
  if (!current_quality) {
    error( VRENERROR_QUALITY_NOT_SET );
    return;
  }
  if (!current_geom) {
    error( VRENERROR_GEOM_NOT_SET );
    return;
  }

  // Record that we are starting the task
  char msg_buf[80];
  sprintf(msg_buf,"rendering by children at: %4d %4d", xsize, ysize);
  logger->comment(msg_buf);

  // Tell the compositor to note the time, so it can say how long rendering
  // took.
  compositor->note_start_time();

  baseVRen::setCamera( camera_in );
  baseVRen::setLightInfo( lights_in );

  // Set up for proper compositing, remembering to transform viewpoint
  gTransfm view_trans= current_geom->volgob()->transform();
  view_trans.transpose_self();
  compositor->set_lookfrom( view_trans*(current_camera->from()) );
  compositor->set_boundbox(current_geom->volgob()->samplevolume()->boundbox());

  // Fire up the children
  for (int i=0; i<nchildren; i++) 
    children[i]->update_and_go( camera_in, lights_in, xsize, ysize );

}

VolGob *compVRen::create_volgob( baseSampleVolume *vol, 
				 const gTransfm& trans )
{
  return( new compVolGob( vol, trans, nchildren, children ) );
}

baseTransferFunction* compVRen::register_tfun( baseTransferFunction *tfun_in )
{
  baseTransferFunction **tfun_table= new baseTransferFunction*[nchildren];
  for (int i=0; i<nchildren; i++) 
    tfun_table[i]= children[i]->register_tfun( tfun_in );
  baseTransferFunction *result= 
    new compTransferFunction(tfun_in->ndata(), nchildren, tfun_table);
  delete [] tfun_table;
  return result;
}
